"""
数据清洗模块单元测试

测试范围：
1. DataValidator - 数据验证
2. DataNormalizer - 数据标准化
3. QualityController - 质量控制

教学要点：
1. 数据质量检查
2. 异常值检测
3. 标准化策略
"""

import pytest
from datetime import datetime
from decimal import Decimal

from src.cherryquant.data.cleaners.validator import (
    DataValidator,
    ValidationResult,
    ValidationDimension,
)
from src.cherryquant.data.cleaners.normalizer import (
    DataNormalizer,
    NormalizationStrategy,
)
from src.cherryquant.data.cleaners.quality_control import (
    QualityController,
    QualityGrade,
)


# ==================== DataValidator 测试 ====================

class TestDataValidator:
    """测试数据验证器"""

    @pytest.fixture
    def validator(self):
        return DataValidator()

    @pytest.fixture
    def valid_data(self):
        """有效数据"""
        return [
            {
                "symbol": "rb2501",
                "datetime": datetime(2024, 1, 1),
                "open": 3500.0,
                "high": 3520.0,
                "low": 3480.0,
                "close": 3510.0,
                "volume": 100000,
            },
            {
                "symbol": "rb2501",
                "datetime": datetime(2024, 1, 2),
                "open": 3510.0,
                "high": 3540.0,
                "low": 3500.0,
                "close": 3530.0,
                "volume": 120000,
            },
        ]

    def test_validate_valid_data(self, validator, valid_data):
        """测试验证有效数据"""
        result = validator.validate(valid_data)

        assert result.is_valid == True
        assert len(result.errors) == 0

    def test_check_missing_values(self, validator):
        """测试缺失值检查"""
        data_with_missing = [
            {
                "symbol": "rb2501",
                "datetime": datetime(2024, 1, 1),
                "open": 3500.0,
                "high": None,  # 缺失
                "low": 3480.0,
                "close": 3510.0,
                "volume": 100000,
            }
        ]

        result = validator.validate(data_with_missing)

        assert result.is_valid == False
        assert any("缺失" in str(err) or "missing" in str(err).lower() for err in result.errors)

    def test_check_data_types(self, validator):
        """测试数据类型检查"""
        data_with_wrong_type = [
            {
                "symbol": "rb2501",
                "datetime": datetime(2024, 1, 1),
                "open": "not_a_number",  # 错误类型
                "high": 3520.0,
                "low": 3480.0,
                "close": 3510.0,
                "volume": 100000,
            }
        ]

        result = validator.validate(data_with_wrong_type)

        assert result.is_valid == False

    def test_check_price_ranges(self, validator):
        """测试价格范围检查"""
        data_with_invalid_range = [
            {
                "symbol": "rb2501",
                "datetime": datetime(2024, 1, 1),
                "open": 3500.0,
                "high": 3480.0,  # high < low，不合理
                "low": 3520.0,
                "close": 3510.0,
                "volume": 100000,
            }
        ]

        result = validator.validate(data_with_invalid_range)

        assert result.is_valid == False

    def test_detect_outliers_iqr(self, validator):
        """测试 IQR 异常值检测"""
        data = []
        # 正常数据
        for i in range(20):
            data.append({
                "symbol": "rb2501",
                "datetime": datetime(2024, 1, i+1),
                "open": 3500.0 + i,
                "high": 3520.0 + i,
                "low": 3480.0 + i,
                "close": 3510.0 + i,
                "volume": 100000,
            })

        # 添加异常值
        data.append({
            "symbol": "rb2501",
            "datetime": datetime(2024, 1, 21),
            "open": 5000.0,  # 明显异常
            "high": 5020.0,
            "low": 4980.0,
            "close": 5010.0,
            "volume": 100000,
        })

        outliers = validator.detect_outliers(data, column="open", method="iqr")

        assert len(outliers) > 0
        assert 5000.0 in [o["open"] for o in outliers]

    def test_check_consistency(self, validator):
        """测试一致性检查"""
        inconsistent_data = [
            {
                "symbol": "rb2501",
                "datetime": datetime(2024, 1, 1),
                "open": 3500.0,
                "high": 3520.0,
                "low": 3480.0,
                "close": 3510.0,
                "volume": 100000,
            },
            {
                "symbol": "hc2501",  # 不同品种，可能不一致
                "datetime": datetime(2024, 1, 1),
                "open": 3200.0,
                "high": 3220.0,
                "low": 3180.0,
                "close": 3210.0,
                "volume": 80000,
            },
        ]

        # 检查品种一致性
        is_consistent = validator.check_consistency(inconsistent_data, dimension="symbol")

        assert is_consistent == False


# ==================== DataNormalizer 测试 ====================

class TestDataNormalizer:
    """测试数据标准化器"""

    @pytest.fixture
    def normalizer(self):
        return DataNormalizer()

    @pytest.fixture
    def sample_data(self):
        return [
            {"value": 100.0},
            {"value": 200.0},
            {"value": 300.0},
            {"value": 400.0},
            {"value": 500.0},
        ]

    def test_z_score_normalization(self, normalizer, sample_data):
        """测试 Z-Score 标准化"""
        result = normalizer.normalize(
            sample_data,
            column="value",
            strategy=NormalizationStrategy.Z_SCORE
        )

        # Z-Score 标准化后，均值应该接近 0，标准差接近 1
        values = [r["value_normalized"] for r in result]
        mean = sum(values) / len(values)
        assert abs(mean) < 0.01  # 接近 0

    def test_min_max_normalization(self, normalizer, sample_data):
        """测试 MinMax 标准化"""
        result = normalizer.normalize(
            sample_data,
            column="value",
            strategy=NormalizationStrategy.MIN_MAX
        )

        # MinMax 标准化后，值应该在 [0, 1] 之间
        values = [r["value_normalized"] for r in result]
        assert min(values) == pytest.approx(0.0)
        assert max(values) == pytest.approx(1.0)
        assert all(0 <= v <= 1 for v in values)

    def test_robust_normalization(self, normalizer):
        """测试 Robust 标准化（对异常值鲁棒）"""
        data_with_outlier = [
            {"value": 100.0},
            {"value": 110.0},
            {"value": 105.0},
            {"value": 10000.0},  # 异常值
        ]

        result = normalizer.normalize(
            data_with_outlier,
            column="value",
            strategy=NormalizationStrategy.ROBUST
        )

        # Robust 标准化应该不受异常值影响
        values = [r["value_normalized"] for r in result]

        # 正常值应该接近
        assert abs(values[0] - values[1]) < 2.0  # 相对接近

    def test_log_normalization(self, normalizer, sample_data):
        """测试对数标准化"""
        result = normalizer.normalize(
            sample_data,
            column="value",
            strategy=NormalizationStrategy.LOG
        )

        # 对数标准化后，值应该是正数
        values = [r["value_normalized"] for r in result]
        assert all(v > 0 for v in values)

    def test_decimal_normalization(self, normalizer):
        """测试小数标准化"""
        data = [
            {"value": 123.456},
            {"value": 234.567},
            {"value": 345.678},
        ]

        result = normalizer.normalize(
            data,
            column="value",
            strategy=NormalizationStrategy.DECIMAL
        )

        # 小数标准化应该缩放到合适范围
        values = [r["value_normalized"] for r in result]
        assert all(0.1 < v < 10.0 for v in values)


# ==================== QualityController 测试 ====================

class TestQualityController:
    """测试质量控制器"""

    @pytest.fixture
    def controller(self):
        return QualityController()

    def test_grade_excellent_data(self, controller):
        """测试优秀数据评分"""
        excellent_data = []
        for i in range(100):
            excellent_data.append({
                "symbol": "rb2501",
                "datetime": datetime(2024, 1, 1) + timedelta(hours=i),
                "open": 3500.0 + i * 0.5,
                "high": 3510.0 + i * 0.5,
                "low": 3490.0 + i * 0.5,
                "close": 3505.0 + i * 0.5,
                "volume": 100000,
            })

        grade, score = controller.grade_data(excellent_data)

        # 应该是 A 或 B 级
        assert grade in [QualityGrade.A, QualityGrade.B]
        assert score >= 80

    def test_grade_poor_data(self, controller):
        """测试低质量数据评分"""
        poor_data = [
            {
                "symbol": "rb2501",
                "datetime": datetime(2024, 1, 1),
                "open": None,  # 缺失
                "high": 3520.0,
                "low": 3480.0,
                "close": 3510.0,
                "volume": 100000,
            },
            {
                "symbol": "rb2501",
                "datetime": datetime(2024, 1, 2),
                "open": 3500.0,
                "high": 3400.0,  # high < low
                "low": 3480.0,
                "close": 3510.0,
                "volume": 100000,
            },
        ]

        grade, score = controller.grade_data(poor_data)

        # 应该是 D 或 F 级
        assert grade in [QualityGrade.D, QualityGrade.F]
        assert score < 60

    def test_calculate_completeness(self, controller):
        """测试完整性计算"""
        data_with_missing = [
            {"a": 1, "b": 2, "c": 3},
            {"a": 1, "b": None, "c": 3},  # 1 个缺失
            {"a": 1, "b": 2, "c": None},  # 1 个缺失
        ]

        completeness = controller.calculate_completeness(data_with_missing)

        # 9 个值中有 7 个有效，完整性应该是 77.7%
        assert completeness == pytest.approx(7/9, rel=0.01)

    def test_calculate_accuracy(self, controller):
        """测试准确性计算"""
        data = [
            {"value": 100.0},
            {"value": 101.0},
            {"value": 102.0},
            {"value": 500.0},  # 异常值
        ]

        accuracy = controller.calculate_accuracy(data, column="value")

        # 有 1/4 的异常值，准确性应该是 75%
        assert accuracy == pytest.approx(0.75, rel=0.1)


# ==================== 集成测试 ====================

class TestCleanersPipeline:
    """测试清洗流程集成"""

    def test_full_cleaning_pipeline(self):
        """测试完整的清洗流程"""
        # 原始数据（包含各种问题）
        raw_data = [
            {
                "symbol": "rb2501",
                "datetime": datetime(2024, 1, 1),
                "open": 3500.0,
                "high": 3520.0,
                "low": 3480.0,
                "close": 3510.0,
                "volume": 100000,
            },
            {
                "symbol": "rb2501",
                "datetime": datetime(2024, 1, 2),
                "open": 3510.0,
                "high": None,  # 缺失值
                "low": 3500.0,
                "close": 3530.0,
                "volume": 120000,
            },
            {
                "symbol": "rb2501",
                "datetime": datetime(2024, 1, 3),
                "open": 3530.0,
                "high": 5000.0,  # 异常值
                "low": 3520.0,
                "close": 3540.0,
                "volume": 110000,
            },
        ]

        # 1. 验证
        validator = DataValidator()
        validation_result = validator.validate(raw_data)
        assert validation_result.is_valid == False  # 有问题

        # 2. 清理（移除有问题的行）
        clean_data = [d for d in raw_data if validator.validate([d]).is_valid]

        # 3. 标准化
        normalizer = DataNormalizer()
        normalized_data = normalizer.normalize(
            clean_data,
            column="close",
            strategy=NormalizationStrategy.Z_SCORE
        )

        # 4. 质量评分
        controller = QualityController()
        grade, score = controller.grade_data(clean_data)

        # 清理后应该质量更高
        assert len(clean_data) <= len(raw_data)
        assert score > 0


from datetime import timedelta  # 需要导入
