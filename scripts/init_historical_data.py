#!/usr/bin/env python3
"""
å†å²æ•°æ®åˆå§‹åŒ–å·¥å…·
ç”¨äºé¦–æ¬¡å¯åŠ¨æ—¶æ‰¹é‡ä¸‹è½½æœŸè´§å†å²æ•°æ®åˆ°æ•°æ®åº“
"""

import asyncio
import sys
import os
from pathlib import Path
from datetime import datetime, timedelta
from typing import List, Dict, Optional
import logging
import pandas as pd



from cherryquant.adapters.data_storage.database_manager import get_database_manager
from cherryquant.adapters.data_storage.timeframe_data_manager import TimeFrame, MarketDataPoint
from config.database_config import get_database_config
import tushare as ts

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


class HistoricalDataInitializer:
    """å†å²æ•°æ®åˆå§‹åŒ–å™¨"""

    # ä¸»æµæœŸè´§å“ç§
    POPULAR_SYMBOLS = {
        "SHFE": ["rb", "hc", "cu", "al", "zn", "au", "ag", "ni"],  # ä¸ŠæœŸæ‰€
        "DCE": ["i", "j", "jm", "a", "c", "m", "y", "p"],  # å¤§å•†æ‰€
        "CZCE": ["SR", "CF", "TA", "MA", "RM", "OI"],  # éƒ‘å•†æ‰€
        "CFFEX": ["IF", "IC", "IH", "T", "TF"]  # ä¸­é‡‘æ‰€
    }

    # æ•°æ®ä¸‹è½½ç­–ç•¥
    DATA_STRATEGIES = {
        "1d": {"name": "æ—¥çº¿", "days": 365, "desc": "æœ€è¿‘1å¹´"},
        "1m": {"name": "1åˆ†é’Ÿ", "days": 5, "desc": "æœ€è¿‘5å¤©"},
        "5m": {"name": "5åˆ†é’Ÿ", "days": 30, "desc": "æœ€è¿‘1ä¸ªæœˆ"},
        "10m": {"name": "10åˆ†é’Ÿ", "days": 60, "desc": "æœ€è¿‘2ä¸ªæœˆ"},
        "30m": {"name": "30åˆ†é’Ÿ", "days": 180, "desc": "æœ€è¿‘åŠå¹´"},
        "1h": {"name": "1å°æ—¶", "days": 365, "desc": "æœ€è¿‘1å¹´"},
    }

    def __init__(self, tushare_token: str):
        """åˆå§‹åŒ–"""
        self.tushare_token = tushare_token
        self.tushare_pro = None
        self.db_manager = None

        if tushare_token and tushare_token != "your_tushare_pro_token_here":
            try:
                ts.set_token(tushare_token)
                self.tushare_pro = ts.pro_api()
                logger.info("âœ… Tushare Pro API åˆå§‹åŒ–æˆåŠŸ")
            except Exception as e:
                logger.error(f"âŒ Tushare Pro API åˆå§‹åŒ–å¤±è´¥: {e}")
        else:
            logger.warning("âš ï¸ Tushare Token æœªé…ç½®")

    async def _ensure_db_manager(self) -> None:
        """ç¡®ä¿æ•°æ®åº“ç®¡ç†å™¨å·²åˆå§‹åŒ–"""
        if self.db_manager is None:
            db_config = get_database_config()
            self.db_manager = await get_database_manager(db_config)
            logger.info("âœ… æ•°æ®åº“è¿æ¥å·²å»ºç«‹")

    async def check_database_status(self) -> Dict[str, int]:
        """æ£€æŸ¥æ•°æ®åº“ä¸­çš„æ•°æ®çŠ¶æ€"""
        try:
            await self._ensure_db_manager()

            async with self.db_manager.postgres_pool.acquire() as conn:
                # ç»Ÿè®¡å„æ—¶é—´å‘¨æœŸçš„æ•°æ®é‡
                stats = {}
                for timeframe in ["5m", "10m", "30m", "1H", "1d"]:
                    result = await conn.fetchval(
                        "SELECT COUNT(*) FROM market_data WHERE timeframe = $1",
                        timeframe
                    )
                    stats[timeframe] = result or 0

                return stats

        except Exception as e:
            logger.error(f"æ£€æŸ¥æ•°æ®åº“çŠ¶æ€å¤±è´¥: {e}")
            return {}

    async def download_futures_data(
        self,
        symbol: str,
        exchange: str,
        timeframe: str,
        days: int
    ) -> List[MarketDataPoint]:
        """ä¸‹è½½æœŸè´§å†å²æ•°æ®"""
        if not self.tushare_pro:
            logger.error("Tushare API æœªåˆå§‹åŒ–")
            return []

        try:
            # è®¡ç®—æ—¶é—´èŒƒå›´
            end_date = datetime.now()
            start_date = end_date - timedelta(days=days)

            # Tushare å“ç§ä»£ç æ ¼å¼ï¼ˆéœ€è¦ä¸»åŠ›åˆçº¦ï¼‰
            # ç®€åŒ–å¤„ç†ï¼šæš‚æ—¶ä½¿ç”¨å½“å‰ä¸»åŠ›åˆçº¦
            ts_code = self._get_dominant_contract(symbol, exchange)

            if not ts_code:
                logger.warning(f"æ— æ³•è·å– {symbol} çš„ä¸»åŠ›åˆçº¦")
                return []

            # æ ¹æ®æ—¶é—´å‘¨æœŸé€‰æ‹©API
            if timeframe == "1d":
                # æ—¥çº¿æ•°æ®
                df = self.tushare_pro.fut_daily(
                    ts_code=ts_code,
                    start_date=start_date.strftime("%Y%m%d"),
                    end_date=end_date.strftime("%Y%m%d")
                )
                all_data_points = self._convert_dataframe_to_points(df, timeframe)
            else:
                # åˆ†é’Ÿçº¿æ•°æ®ï¼ˆéœ€è¦2000+ç§¯åˆ†ï¼‰- éœ€è¦åˆ†é¡µè·å–
                all_data_points = await self._download_minutes_data_paginated(
                    ts_code, symbol, exchange, timeframe, start_date, end_date
                )

            logger.info(f"âœ… ä¸‹è½½ {symbol}.{exchange} {timeframe} æ•°æ®: {len(all_data_points)} æ¡")
            return all_data_points

        except Exception as e:
            logger.error(f"ä¸‹è½½ {symbol} æ•°æ®å¤±è´¥: {e}")
            return []

    async def _download_minutes_data_paginated(
        self,
        ts_code: str,
        symbol: str,
        exchange: str,
        timeframe: str,
        start_date: datetime,
        end_date: datetime
    ) -> List[MarketDataPoint]:
        """åˆ†é¡µä¸‹è½½åˆ†é’Ÿçº¿æ•°æ®ï¼Œå¤„ç†8000æ¡é™åˆ¶"""
        freq_map = {
            "5m": "5min",
            "10m": "10min",
            "30m": "30min",
            "1h": "60min"
        }
        freq = freq_map.get(timeframe, "5min")

        # æ ¹æ®é¢‘ç‡è®¡ç®—å®‰å…¨çš„æ—¶é—´é—´éš”ï¼ˆç¡®ä¿ä¸è¶…è¿‡8000æ¡ï¼‰
        interval_days = self._get_safe_interval_days(timeframe)

        all_data_points = []
        current_start = start_date

        while current_start < end_date:
            # è®¡ç®—å½“å‰æ‰¹æ¬¡çš„ç»“æŸæ—¶é—´
            current_end = min(current_start + timedelta(days=interval_days), end_date)

            try:
                logger.debug(f"ä¸‹è½½ {symbol}.{exchange} {timeframe} æ•°æ®: {current_start} åˆ° {current_end}")

                df = self.tushare_pro.ft_mins(
                    ts_code=ts_code,
                    freq=freq,
                    start_date=current_start.strftime("%Y%m%d %H:%M:%S"),
                    end_date=current_end.strftime("%Y%m%d %H:%M:%S")
                )

                if df is not None and not df.empty:
                    batch_points = self._convert_dataframe_to_points(df, timeframe)
                    all_data_points.extend(batch_points)
                    logger.debug(f"æ‰¹æ¬¡è·å– {len(batch_points)} æ¡æ•°æ®")

                    # å¦‚æœè·å–åˆ°äº†æ•°æ®ï¼Œæ­£å¸¸ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªæ—¶é—´æ®µ
                    current_start = current_end
                else:
                    logger.debug(f"æ‰¹æ¬¡æ— æ•°æ®: {current_start} åˆ° {current_end}")
                    # å¦‚æœæ²¡æœ‰æ•°æ®ï¼Œå¯èƒ½æ˜¯å› ä¸ºå‘¨æœ«/èŠ‚å‡æ—¥ï¼Œå°è¯•è·³è¿‡æ›´å¤§çš„é—´éš”
                    # ä½†ä¹Ÿè¦é¿å…æ— é™å¾ªç¯ï¼Œæ‰€ä»¥è‡³å°‘å‰è¿›1å¤©
                    next_start = current_start + timedelta(days=1)
                    if next_start <= current_end:
                        current_start = next_start
                    else:
                        current_start = current_end

                # é¿å…è¯·æ±‚è¿‡å¿«
                await asyncio.sleep(0.3)

            except Exception as e:
                logger.error(f"ä¸‹è½½æ‰¹æ¬¡æ•°æ®å¤±è´¥ ({current_start} åˆ° {current_end}): {e}")
                # å¦‚æœè¿ç»­å¤±è´¥ï¼Œè·³è¿‡è¿™ä¸ªæ—¶é—´æ®µ
                current_start = current_end
                await asyncio.sleep(1)  # å»¶é•¿ç­‰å¾…æ—¶é—´

        return all_data_points

    def _get_safe_interval_days(self, timeframe: str) -> int:
        """æ ¹æ®æ—¶é—´å‘¨æœŸè¿”å›å®‰å…¨çš„å¤©æ•°é—´éš”ï¼ˆç¡®ä¿ä¸è¶…è¿‡8000æ¡ï¼‰"""
        # æ›´ç²¾ç¡®çš„è®¡ç®—ï¼Œè€ƒè™‘äº¤æ˜“æ—¶é—´ï¼ˆå‡è®¾æ¯å¤©6.5å°æ—¶äº¤æ˜“æ—¶é—´ï¼‰
        # å®é™…æœŸè´§äº¤æ˜“æ—¶é—´æ›´é•¿ï¼Œä½†ä¿å®ˆä¼°è®¡ä½¿ç”¨6.5å°æ—¶
        trading_hours_per_day = 6.5

        if timeframe == "1m":
            minutes_per_day = int(trading_hours_per_day * 60)  # ~390åˆ†é’Ÿ/å¤©
            safe_days = int(8000 / minutes_per_day * 0.9)  # 90%å®‰å…¨ç³»æ•°
            return max(1, safe_days)  # è‡³å°‘1å¤©
        elif timeframe == "5m":
            intervals_per_day = int(trading_hours_per_day * 12)  # ~78ä¸ª5åˆ†é’ŸKçº¿/å¤©
            safe_days = int(8000 / intervals_per_day * 0.9)
            return max(5, safe_days)
        elif timeframe == "10m":
            intervals_per_day = int(trading_hours_per_day * 6)  # ~39ä¸ª10åˆ†é’ŸKçº¿/å¤©
            safe_days = int(8000 / intervals_per_day * 0.9)
            return max(10, safe_days)
        elif timeframe == "30m":
            intervals_per_day = int(trading_hours_per_day * 2)  # ~13ä¸ª30åˆ†é’ŸKçº¿/å¤©
            safe_days = int(8000 / intervals_per_day * 0.9)
            return max(30, safe_days)
        elif timeframe == "1h":
            intervals_per_day = int(trading_hours_per_day)  # ~6ä¸ª1å°æ—¶Kçº¿/å¤©
            safe_days = int(8000 / intervals_per_day * 0.9)
            return max(60, safe_days)
        else:
            # é»˜è®¤ä½¿ç”¨5mçš„è®¾ç½®
            return 25

    def _convert_dataframe_to_points(self, df, timeframe: str) -> List[MarketDataPoint]:
        """å°†DataFrameè½¬æ¢ä¸ºMarketDataPointåˆ—è¡¨"""
        if df is None or df.empty:
            return []

        data_points = []
        for _, row in df.iterrows():
            try:
                # åˆ†é’Ÿçº¿æ•°æ®çš„trade_dateæ ¼å¼å¯èƒ½æ˜¯ "YYYY-MM-DD HH:MM:SS"
                trade_date_str = str(row['trade_date'])
                if ' ' in trade_date_str:
                    # åˆ†é’Ÿçº¿æ ¼å¼
                    timestamp = datetime.strptime(trade_date_str, "%Y-%m-%d %H:%M:%S")
                else:
                    # æ—¥çº¿æ ¼å¼
                    timestamp = datetime.strptime(trade_date_str, "%Y%m%d")

                dp = MarketDataPoint(
                    timestamp=timestamp,
                    open=float(row['open']),
                    high=float(row['high']),
                    low=float(row['low']),
                    close=float(row['close']),
                    volume=int(row['vol']) if 'vol' in row and pd.notna(row['vol']) else 0,
                    open_interest=int(row['oi']) if 'oi' in row and pd.notna(row['oi']) else 0
                )
                data_points.append(dp)
            except Exception as e:
                logger.debug(f"è½¬æ¢æ•°æ®ç‚¹å¤±è´¥: {e}")
                continue

        return data_points

    def _get_dominant_contract(self, symbol: str, exchange: str) -> Optional[str]:
        """è·å–ä¸»åŠ›åˆçº¦ä»£ç ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰"""
        try:
            # æŸ¥è¯¢ä¸»åŠ›åˆçº¦æ˜ å°„
            df = self.tushare_pro.fut_mapping(ts_code=f"{symbol.upper()}.{exchange}")
            if df is not None and not df.empty:
                return df.iloc[0]['mapping_ts_code']
        except Exception as e:
            logger.debug(f"è·å–ä¸»åŠ›åˆçº¦å¤±è´¥: {e}")

        # é™çº§æ–¹æ¡ˆï¼šæ¨ç®—è¿‘æœˆåˆçº¦
        year = datetime.now().year
        month = datetime.now().month + 1
        if month > 12:
            year += 1
            month = 1

        return f"{symbol}{year % 100}{month:02d}.{exchange}"

    async def save_to_database(
        self,
        symbol: str,
        exchange: str,
        timeframe: str,
        data_points: List[MarketDataPoint]
    ) -> int:
        """ä¿å­˜æ•°æ®åˆ°æ•°æ®åº“"""
        if not self.db_manager or not data_points:
            return 0

        try:
            saved = 0
            async with self.db_manager.postgres_pool.acquire() as conn:
                for dp in data_points:
                    try:
                        await conn.execute(
                            """
                            INSERT INTO market_data (
                                time, symbol, exchange, timeframe,
                                open_price, high_price, low_price, close_price,
                                volume, open_interest
                            ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
                            ON CONFLICT (time, symbol, exchange, timeframe) DO NOTHING
                            """,
                            dp.timestamp, symbol, exchange, timeframe,
                            dp.open, dp.high, dp.low, dp.close,
                            dp.volume, dp.open_interest
                        )
                        saved += 1
                    except Exception as e:
                        logger.debug(f"ä¿å­˜æ•°æ®ç‚¹å¤±è´¥: {e}")
                        continue

            logger.info(f"ğŸ’¾ ä¿å­˜ {symbol}.{exchange} {timeframe}: {saved}/{len(data_points)} æ¡")
            return saved

        except Exception as e:
            logger.error(f"ä¿å­˜æ•°æ®åˆ°æ•°æ®åº“å¤±è´¥: {e}")
            return 0

    async def initialize_data(
        self,
        symbols: Optional[Dict[str, List[str]]] = None,
        timeframes: Optional[List[str]] = None
    ) -> Dict[str, Dict[str, int]]:
        """åˆå§‹åŒ–å†å²æ•°æ®"""
        # ç¡®ä¿æ•°æ®åº“è¿æ¥å·²å»ºç«‹
        await self._ensure_db_manager()

        if symbols is None:
            symbols = self.POPULAR_SYMBOLS

        if timeframes is None:
            timeframes = ["1d", "5m", "30m", "1h"]

        results = {}
        total_downloaded = 0
        total_saved = 0

        print("\n" + "="*70)
        print("ğŸš€ å¼€å§‹ä¸‹è½½å†å²æ•°æ®")
        print("="*70)

        for exchange, symbol_list in symbols.items():
            results[exchange] = {}

            for symbol in symbol_list:
                print(f"\nğŸ“Š å¤„ç†å“ç§: {symbol}.{exchange}")

                for tf in timeframes:
                    strategy = self.DATA_STRATEGIES.get(tf, {})
                    days = strategy.get("days", 30)
                    desc = strategy.get("desc", "")

                    print(f"  â¬ ä¸‹è½½ {tf} æ•°æ® ({desc})...", end=" ", flush=True)

                    # ä¸‹è½½æ•°æ®
                    data_points = await self.download_futures_data(
                        symbol, exchange, tf, days
                    )

                    if data_points:
                        # ä¿å­˜åˆ°æ•°æ®åº“
                        saved = await self.save_to_database(
                            symbol, exchange, tf, data_points
                        )
                        results[exchange][f"{symbol}_{tf}"] = saved
                        total_downloaded += len(data_points)
                        total_saved += saved
                        print(f"âœ… {saved} æ¡")
                    else:
                        print("âš ï¸ æ— æ•°æ®")

                    # é¿å…è¯·æ±‚è¿‡å¿«
                    await asyncio.sleep(0.5)

        print("\n" + "="*70)
        print(f"âœ… æ•°æ®åˆå§‹åŒ–å®Œæˆï¼")
        print(f"ğŸ“¥ å…±ä¸‹è½½: {total_downloaded} æ¡")
        print(f"ğŸ’¾ å·²ä¿å­˜: {total_saved} æ¡")
        print("="*70 + "\n")

        return results


async def interactive_init():
    """äº¤äº’å¼åˆå§‹åŒ–"""
    print("\n" + "="*70)
    print("ğŸ’ CherryQuant å†å²æ•°æ®åˆå§‹åŒ–å·¥å…·")
    print("="*70)

    # è·å– Tushare Token
    tushare_token = os.getenv("TUSHARE_TOKEN")
    if not tushare_token or tushare_token == "your_tushare_pro_token_here":
        print("\nâŒ é”™è¯¯: TUSHARE_TOKEN æœªé…ç½®")
        print("è¯·åœ¨ .env æ–‡ä»¶ä¸­é…ç½® TUSHARE_TOKEN")
        print("æ³¨æ„: ä¸‹è½½åˆ†é’Ÿçº¿æ•°æ®éœ€è¦ Tushare Pro 2000+ ç§¯åˆ†")
        return

    # åˆå§‹åŒ–å™¨
    initializer = HistoricalDataInitializer(tushare_token)

    # æ£€æŸ¥æ•°æ®åº“çŠ¶æ€
    print("\nğŸ” æ£€æŸ¥æ•°æ®åº“çŠ¶æ€...")
    stats = await initializer.check_database_status()

    print("\nå½“å‰æ•°æ®åº“ä¸­çš„æ•°æ®é‡:")
    for tf, count in stats.items():
        print(f"  {tf:6s}: {count:8d} æ¡")

    total_records = sum(stats.values())
    print(f"\næ€»è®¡: {total_records} æ¡è®°å½•")

    # è¯¢é—®æ˜¯å¦éœ€è¦ä¸‹è½½
    if total_records > 0:
        print("\næ•°æ®åº“ä¸­å·²æœ‰æ•°æ®ã€‚")
        response = input("æ˜¯å¦è¦é‡æ–°ä¸‹è½½/è¡¥å……æ•°æ®ï¼Ÿ(y/n): ").lower().strip()
        if response != 'y':
            print("å·²å–æ¶ˆã€‚")
            return
    else:
        print("\nâš ï¸  æ•°æ®åº“ä¸ºç©ºï¼Œå»ºè®®ä¸‹è½½å†å²æ•°æ®ä»¥å¯åŠ¨ç³»ç»Ÿã€‚")
        response = input("æ˜¯å¦ç°åœ¨ä¸‹è½½ï¼Ÿ(y/n): ").lower().strip()
        if response != 'y':
            print("å·²å–æ¶ˆã€‚å¯ä»¥éšæ—¶è¿è¡Œæ­¤è„šæœ¬åˆå§‹åŒ–æ•°æ®ã€‚")
            return

    # é€‰æ‹©ä¸‹è½½ç­–ç•¥
    print("\nè¯·é€‰æ‹©è¦ä¸‹è½½çš„æ•°æ®ç±»å‹:")
    print("  1. ä»…æ—¥çº¿æ•°æ® (å¿«é€Ÿï¼Œé€‚åˆæµ‹è¯•)")
    print("  2. æ—¥çº¿ + å°æ—¶çº¿ (æ¨è)")
    print("  3. å…¨éƒ¨æ•°æ® (æ—¥çº¿ã€å°æ—¶ã€30åˆ†é’Ÿã€10åˆ†é’Ÿã€5åˆ†é’Ÿã€1åˆ†é’Ÿ)")
    print("  4. è‡ªå®šä¹‰")

    choice = input("è¯·è¾“å…¥é€‰é¡¹ (1-4, é»˜è®¤ 2): ").strip() or "2"

    if choice == "1":
        timeframes = ["1d"]
    elif choice == "2":
        timeframes = ["1d", "1h"]
    elif choice == "3":
        timeframes = ["1d", "1h", "30m", "10m", "5m", "1m"]
    elif choice == "4":
        print("\nå¯é€‰æ—¶é—´å‘¨æœŸ: 1d, 1h, 30m, 10m, 5m, 1m")
        tf_input = input("è¯·è¾“å…¥æ—¶é—´å‘¨æœŸï¼ˆç”¨ç©ºæ ¼åˆ†éš”ï¼‰: ").strip()
        timeframes = tf_input.split()
    else:
        timeframes = ["1d", "1h"]

    print(f"\nå°†ä¸‹è½½ä»¥ä¸‹æ—¶é—´å‘¨æœŸ: {', '.join(timeframes)}")

    # æ˜¾ç¤ºä¸‹è½½ç­–ç•¥
    print("\næ•°æ®ä¸‹è½½ç­–ç•¥:")
    for tf in timeframes:
        strategy = initializer.DATA_STRATEGIES.get(tf, {})
        print(f"  {tf:6s}: {strategy.get('desc', 'N/A')}")

    # é€‰æ‹©å“ç§
    print("\né€‰æ‹©è¦ä¸‹è½½çš„å“ç§:")
    print("  1. ä¸»æµå“ç§ (é»‘è‰²ç³»ã€æœ‰è‰²ã€åŒ–å·¥ã€å†œäº§å“ã€é‡‘èï¼Œçº¦30ä¸ªå“ç§)")
    print("  2. ä»…é»‘è‰²ç³» (rb, hc, i, j, jm)")
    print("  3. å…¨éƒ¨å“ç§ (æ‰€æœ‰äº¤æ˜“æ‰€)")

    symbol_choice = input("è¯·è¾“å…¥é€‰é¡¹ (1-3, é»˜è®¤ 1): ").strip() or "1"

    if symbol_choice == "2":
        symbols = {"SHFE": ["rb", "hc"], "DCE": ["i", "j", "jm"]}
    elif symbol_choice == "3":
        symbols = initializer.POPULAR_SYMBOLS
    else:
        # ä¸»æµå“ç§ï¼ˆç®€åŒ–ï¼‰
        symbols = {
            "SHFE": ["rb", "hc", "cu", "al"],
            "DCE": ["i", "j", "jm", "m"],
            "CZCE": ["SR", "CF", "TA"],
            "CFFEX": ["IF", "IC"]
        }

    # ç¡®è®¤
    total_combinations = sum(len(v) for v in symbols.values()) * len(timeframes)
    print(f"\nå°†ä¸‹è½½ {total_combinations} ä¸ªæ•°æ®é›†")
    print("âš ï¸  æ³¨æ„: è¿™å¯èƒ½éœ€è¦å‡ åˆ†é’Ÿåˆ°åå‡ åˆ†é’Ÿæ—¶é—´")

    confirm = input("\nç¡®è®¤å¼€å§‹ä¸‹è½½ï¼Ÿ(y/n): ").lower().strip()
    if confirm != 'y':
        print("å·²å–æ¶ˆã€‚")
        return

    # å¼€å§‹ä¸‹è½½
    results = await initializer.initialize_data(symbols, timeframes)

    print("\nâœ… åˆå§‹åŒ–å®Œæˆï¼ç°åœ¨å¯ä»¥å¯åŠ¨ CherryQuant ç³»ç»Ÿäº†ã€‚")


async def main():
    """ä¸»å‡½æ•°"""
    if len(sys.argv) > 1 and sys.argv[1] == '--auto':
        # è‡ªåŠ¨æ¨¡å¼ï¼šå¿«é€Ÿåˆå§‹åŒ–æœ€å°æ•°æ®é›†
        print("ğŸ¤– è‡ªåŠ¨æ¨¡å¼ï¼šå¿«é€Ÿåˆå§‹åŒ–...")
        tushare_token = os.getenv("TUSHARE_TOKEN")
        initializer = HistoricalDataInitializer(tushare_token)

        # ä»…ä¸‹è½½ä¸»æµå“ç§çš„æ—¥çº¿æ•°æ®
        symbols = {
            "SHFE": ["rb", "cu"],
            "DCE": ["i", "j"],
        }
        await initializer.initialize_data(symbols, ["1d"])
    else:
        # äº¤äº’æ¨¡å¼
        await interactive_init()


if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\n\nğŸ‘‹ å·²å–æ¶ˆ")
    except Exception as e:
        logger.error(f"ç¨‹åºå¼‚å¸¸: {e}", exc_info=True)
